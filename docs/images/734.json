{"id":734,"date":"2009-07-25T20:30:00","date_gmt":"2009-07-25T19:30:00","guid":{"rendered":"http:\/\/www.xoodbs.net\/?p=734"},"modified":"2021-09-18T13:53:50","modified_gmt":"2021-09-18T11:53:50","slug":"are-interfaces-evil-or-misused","status":"publish","type":"post","link":"https:\/\/www.ordisoftware.com\/blog\/2009\/07\/are-interfaces-evil-or-misused\/","title":{"rendered":"Les interfaces sont-elles un fl\u00e9au ou sont-elles mal utilis\u00e9es ?"},"content":{"rendered":"<p style=\"margin-bottom:25px;\"><p><\/p>\n<h3>There are several considerations and practices concerning interfaces<\/h3>\n<p>Some developers say that interfaces can be used as a replacement of multiple inheritance mechanisms, which cause complexity and ambiguity. But each feature must be implemented each time it is declared: this is not an inheritance, this is a wrapper to the description of a part of a group of classes, like IDisposable. It is the same as a multiple inheritance with one implemented class and some abstract classes: it is a particular case which allows only one way hierarchy with interfaces as abstract connectors that describes services.<\/p>\n<p>Some developers say that interfaces can be used to separate the access to an object of this instance. Historically, interfaces are a COM &amp; DCOM heritage: they are used to manipulate components services, whatever objects are, where they are, and how they are implemented. Interfaces are not a replacement to multiple inheritance, they are something else.<\/p>\n<p><em>Recommended articles:<\/em><br \/>\n<a href=\"http:\/\/weblogs.asp.net\/fbouma\/archive\/2004\/01\/04\/47476.aspx\" target=\"_blank\" rel=\"noopener\">A plea for full multiple inheritance support in .NET<\/a><br \/>\n<a href=\"http:\/\/research.microsoft.com\/apps\/pubs\/default.aspx?id=55775\" target=\"_blank\" rel=\"noopener\">A Typed Intermediate Language for Compiling Multiple Inheritance<\/a><\/p>\n<p><!--more--><\/p>\n<h3>Interfaces can be used to solve some design issues in .NET<\/h3>\n<p>In component communication, because they are like a transfer of addresses: \u201cAn interface describes a group of related functionalities that can belong to any class or structure. Interfaces can consist of methods, properties, events, indexers, or any combination of those four member types. An interface cannot contain fields. Interfaces members are automatically public\u201d (MSDN Documentation). To simplify, in distributed computing, a client has an \u201cinstance\u201d of an interface to an object that is on the server.<\/p>\n<p>In the conceptualization of services provided by classes instead of multiple inheritance: this abstraction layer should be separated from the classes layer. It is not an implementation because it is a high-level design view and this should not be coded: a method should not be implemented several times in the same way, which is facilitated by the genericity. An interface corresponds to a fully implemented class, to a class that contains abstract members, or to a fully\/pure abstract class.<\/p>\n<p>To provide a kind of low level polymorphism for generic classes to manipulate all possible linked templates while this feature doesn\u2019t exist in C#: an undetermined type like GenericClass &lt; &gt; can\u2019t be used without providing a specific type unless reflexion is used.<\/p>\n<h4 style=\"padding-left: 30px;\"><em>But they create some problems<\/em><\/h4>\n<p style=\"padding-left: 30px;\">All functionalities must be implemented each time.<br \/>\nThe type dependence is fragmented to the detriment of quality.<br \/>\nThe code complexity is increased: lots of declarations and big code for one class instead of lots of small classes with small code.<\/p>\n<p><em>Using interfaces in implementation increases the abstraction of an abstraction, reduces the code factorization, reduces the maintainability and increases the risks of a project.<\/em><\/p>\n<h3>Multiple inheritance may be used to solve some design problems in .NET<\/h3>\n<p>To inherit from multiple classes and to implement only once a service provided by several classes.<br \/>\nTo have a strongly typed design without seeing double or going crazy.<br \/>\nTo provide a high level of polymorphism.<\/p>\n<h4 style=\"padding-left: 30px;\"><em>But it creates some problems<\/em><\/h4>\n<p style=\"padding-left: 30px;\">All functionalities must be implemented rigorously.<br \/>\nIt requires a study and an understanding of the object programming theory.<br \/>\nThe code complexity is increased: lots of small classes with small code instead of lots of declarations and big code for one class.<\/p>\n<p><em>Using multiple inheritance increases the simplicity of the abstraction (of interfaces, if models are based on), reduces the code size, reduces the confusion about models and increases the safeness of a project.<\/em><\/p>\n<h3>Interfaces don\u2019t compensate for the lack in multiple inheritance as well as in generic polymorphism<\/h3>\n<p>Both have their difficulties, their advantages and their applications : discuss the pros and cons of interfaces is a wrong debate without end.<\/p>\n<p>Code based on interfaces is a default programming and an entangled path based on a difficult simplification of what objects and components are. Interfaces are a full or a partial copy of a class description: they don\u2019t provide better software experience but better ways to design. The mechanisms of interfacing in distributed environment should be provided by the CLR and based on classes descriptions which are the interfaces : the virtual tables.<\/p>\n<p>Of course, do not use interface and multiple inheritance reduces the code complexity, and a developer should have the choice depending of the work.<\/p>\n<p>Consider this code:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">public delegate void ConfigureEvent(IConfigurable value);\r\n\r\npublic interface IConfigurable\r\n{\r\n  ConfigureEvent DoConfiguration { get; set; }\r\n\r\n  void Configure();\r\n}\r\n\r\npublic class ClassA\r\n{\r\n}\r\n\r\npublic class ClassB : IConfigurable\r\n{\r\n  ConfigureEvent IConfigurable.DoConfiguration { get; set; }\r\n\r\n  void IConfigurable.Configure()\r\n  {\r\n    if ( ( (IConfigurable)this ).DoConfiguration != null )\r\n    ( (IConfigurable)this ).DoConfiguration(this);\r\n  }\r\n}\r\n\r\npublic class ClassA1 : ClassA\r\n{\r\n}\r\n\r\npublic class ClassA2 : ClassA, IConfigurable\r\n{\r\n  ConfigureEvent IConfigurable.DoConfiguration { get; set; }\r\n\r\n  void IConfigurable.Configure()\r\n  {\r\n    if ( ( (IConfigurable)this ).DoConfiguration != null )\r\n    ( (IConfigurable)this ).DoConfiguration(this);\r\n  }\r\n}\r\n\r\npublic class ClassA3 : ClassA1, IConfigurable\r\n{\r\n  ConfigureEvent IConfigurable.DoConfiguration { get; set; }\r\n\r\n  void IConfigurable.Configure()\r\n  {\r\n    if ( ( (IConfigurable)this ).DoConfiguration != null )\r\n    ( (IConfigurable)this ).DoConfiguration(this);\r\n  }\r\n}<\/pre>\n<p>The equivalent of these 45 lines in multiple inheritance is simpler and more intuitive. It takes 30 lines: the method is implemented only once, there is no interface because classes structure are the interface, and code is better:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">public delegate void ConfigureEvent(IConfigurable value);\r\n\r\npublic class Configurable\r\n{\r\n  public ConfigureEvent DoConfiguration { get; set; }\r\n\r\n  virtual public void Configure()\r\n  {\r\n    if ( DoConfiguration != null ) DoConfiguration(this);\r\n  }\r\n}\r\n\r\npublic class ClassA\r\n{\r\n}\r\n\r\npublic class ClassB : Configurable\r\n{\r\n}\r\n\r\npublic class ClassA1 : ClassA\r\n{\r\n}\r\n\r\npublic class ClassA2 : ClassA, Configurable\r\n{\r\n}\r\n\r\npublic class ClassA3 : ClassA1, Configurable\r\n{\r\n}<\/pre>\n<p>Supporting generic polymorphism and multiple inheritance in .NET and C# could allow making programs more stable and efficient, as well as coding like this :<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">public class Class1 \r\n{ \r\n  public int Class1Value { get; set; }\r\n}\r\n\r\npublic class Class2\r\n{ \r\n  public int Class2Value { get; set; }\r\n}\r\n\r\npublic class Class3 : Class1 \r\n{ \r\n  public int Class3Value { get; set; }\r\n}\r\n\r\npublic class Class4 &lt; T &gt; : Class3, Class2\r\n{\r\n  public int Class4Value { get; set; }\r\n  public T Value { get; set; }\r\n}\r\n\r\npublic class Class5 &lt; T &gt; : Class4 &lt; T &gt;\r\n{\r\n  public int Class5Value { get; set; }\r\n  public void DoSomething() { }\r\n}\r\n\r\nvoid TestPolymorphism()\r\n{\r\n  var list = new List &lt; class3 &gt;();\r\n\r\n  list.Add(new Class3());\r\n  list.Add(new Class4 &lt; int &gt;());\r\n  list.Add(new Class5 &lt; int &gt;());\r\n  list.Add(new Class5 &lt; string &gt;());\r\n\r\n  foreach (var o in list)\r\n  {\r\n    o.Class1Value = 0;\r\n    o.Class3Value = 0;\r\n\r\n    if (o is Class2) (o as Class2).Class2Value = 0;\r\n    if (o is Class4 &lt; int &gt;) ) (o as Class4 &lt; int &gt;).Value = 0;\r\n\r\n    \/\/ Generic polymorphism and diamond operator is not currently available in csharp\r\n    if (o is Class5 &lt; &gt;) (o as Class5 &lt; &gt;).DoSomething();\r\n  }\r\n}<\/pre>\n<p>It is impossible to write the last line and the problem is solved by using interfaces:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">public interface IClass1 \r\n{ \r\n  int Class1Value { get; set; } \r\n}\r\n\r\npublic interface IClass2\r\n{ \r\n  int Class2Value { get; set; } \r\n}\r\n\r\npublic class Class1 : IClass1\r\n{ \r\n  public int Class1Value { get; set; } \r\n}\r\n\r\npublic class Class2 : IClass2\r\n{ \r\n  public int Class2Value { get; set; } \r\n}\r\n\r\npublic class Class3 : Class1 \r\n{ \r\n  public int Class3Value { get; set; }  \r\n}\r\n\r\npublic class Class4 &lt; T &gt; : Class3, IClass2\r\n{\r\n  public int Class2Value { get; set; } \r\n  public int Class4Value { get; set; }\r\n  public T Value { get; set; }\r\n}\r\n\r\ninterface IClass5 \r\n{ \r\n  int Class5Value { get; set; }\r\n  void DoSomething(); \r\n}\r\n\r\npublic class Class5 &lt; T &gt; : Class4 &lt; T &gt;, IClass5\r\n{\r\n  public int Class5Value { get; set; }\r\n  public void DoSomething() { }\r\n}\r\n\r\nvoid TestPolymorphism()\r\n{\r\n  var list = new List();\r\n\r\n  list.Add(new Class3());\r\n  list.Add(new Class4 &lt; int &gt;());\r\n  list.Add(new Class5 &lt; int &gt;());\r\n  list.Add(new Class5 &lt; string &gt;());\r\n\r\n  foreach (var o in list)\r\n  {\r\n    o.Class1Value = 0;\r\n    o.Class3Value = 0;\r\n\r\n    if (o is IClass2) (o as IClass2).Class2Value = 0;\r\n    if (o is Class4 &lt; int &gt;) ) (o as Class4 &lt; int &gt;).Value = 0;\r\n\r\n    if (o is IClass5) (o as IClass5).DoSomething();\r\n  }\r\n}<\/pre>\n<p>But it is less elegant.<\/p>\n<\/p>","protected":false},"excerpt":{"rendered":"<p style=\"margin-bottom:25px;\">\n<p> There are several considerations and practices concerning interfaces <\/p>\n<p>Some developers say that interfaces can be used as a replacement of multiple inheritance mechanisms, which cause complexity and ambiguity. But each feature must be implemented each time it is declared: this is not an inheritance, this is a wrapper to the description of a part of a group of classes, like IDisposable. It is the same as a multiple inheritance with one implemented class and some abstract classes: it is a particular case which allows only one way hierarchy with interfaces as abstract connectors that describes services.<\/p>\n<p>Some developers <\/p>\n<p><span style=\"color:#333\"> &rarr; <a href=\"https:\/\/www.ordisoftware.com\/blog\/2009\/07\/are-interfaces-evil-or-misused\/\">Lire la suite<\/a><\/span><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[54],"tags":[53,64,28,46,65,66,67,68,57,69,70,37,71,60,72,47,73,74,75,76,32,51,77,78,79,80,81,82],"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts\/734"}],"collection":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/comments?post=734"}],"version-history":[{"count":0,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts\/734\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/media?parent=734"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/categories?post=734"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/tags?post=734"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}