{"id":622,"date":"2009-07-21T10:00:31","date_gmt":"2009-07-21T09:00:31","guid":{"rendered":"http:\/\/www.xoodbs.net\/?p=622"},"modified":"2012-10-27T15:22:37","modified_gmt":"2012-10-27T14:22:37","slug":"design-flaws-of-the-singleton-pattern-in-csharp","status":"publish","type":"post","link":"https:\/\/www.ordisoftware.com\/blog\/2009\/07\/design-flaws-of-the-singleton-pattern-in-csharp\/","title":{"rendered":"Les d\u00e9fauts d'impl\u00e9mentation du pattern singleton"},"content":{"rendered":"<p style=\"margin-bottom:25px;\"><p><\/p>\n<h3>The paradigm<\/h3>\n<p>Consider this common singleton pattern implementation:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">public class Singleton\r\n{\r\n  static private readonly object locker = new object();\r\n\r\n  static public Singleton Instance\r\n  {\r\n    get\r\n    {\r\n      lock ( locker )\r\n      {\r\n        if ( _Instance == null ) _Instance = new Singleton();\r\n        return _Instance;\r\n      }\r\n    }\r\n  }\r\n  static private volatile Singleton _Instance;\r\n\r\n  private Singleton() { }\r\n}<\/pre>\n<p>The problem is that you can inherit this class and create a public constructor if there is no private constructor. Furthermore, static members are allowed. This is no longer a singleton at all. Setting the class as sealed can be an acceptable solution, but you must implement singleton by singleton, i.e., more than ten lines. Thus, coding a such singleton can be the source of many errors and difficulties. Thinking with factoring is not only an agile principle, it is a mathematical theorem.<\/p>\n<h3>Defining a generic singleton<\/h3>\n<p>A generic solution is to check the absence of static members and that there is only one parameterless private constructor, or an exception is thrown. Singletons that inherit this class can't be inherited and must be sealed. Moreover, the implementation of singleton types are checked at program startup. Therefore, it is not the best solution, but the only thing to do is to create one parameterless private constructor, no static members, and seal the class.<\/p>\n<p style=\"margin-left: 30px; margin-top: 15px; margin-bottom: 25px;\"><p style=\"margin-top:0px;margin-bottom:3px;margin-left:15px\">\r\n<img src=\"\/wp-content\/plugins\/wp-downloadmanager\/images\/ext\/zip.gif\" alt=\"\" title=\"\" style=\"vertical-align: middle;\" \/>&nbsp;\r\n<strong><a href=\"https:\/\/www.ordisoftware.com\/?dl_name=GenericPersistentSingleton.zip\">Generic Persistent Singleton Sample<\/a><\/strong>\r\n<\/p>\r\n<p style=\"margin-left:40px;margin-top:0px;color:#555555;font-style:bold;\">\r\n<small><i>\r\nTaille : 53,4 Kio<br \/>\r\nMise en ligne : 28 juillet 2009<br \/>\r\nMise \u00e0 jour : 8 septembre 2015<br \/>\r\nDernier t\u00e9l\u00e9chargement : 9 novembre 2022<br \/>\r\nNombre de t\u00e9l\u00e9chargements : 428\r\n<\/i><\/small>\r\n<\/p><\/p>\n<p><!--more--><\/p>\n<p>Here are members of the proposed singleton:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">abstract public class Singleton &lt; T &gt; where T : Singleton;<\/pre>\n<p>This is the declaration of a generic abstract class where T is a singleton.<\/p>\n<p>By writing this, the type consistency is clear.<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public string Filename;\r\nstatic public void Save();<\/pre>\n<p>It is used to provide storage on disk for persistent singletons and to save their states.<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public T Instance;\r\nstatic public T GetInstance();<\/pre>\n<p>This is the classic access to the instance of the singleton.<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public T GetPersistentInstance(string filename);\r\nstatic public T GetPersistentInstance();<\/pre>\n<p>It creates a persistent instance : it deserialize the object from the disk or create a new. It uses a specific filename or a system name.<\/p>\n<p>Note: defining the name after using the singleton doesn't load a new instance and should throw an error if the localization exists.<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static private T CreateInstance();\r\nstatic internal ConstructorInfo CheckImplementation();<\/pre>\n<p>This creates the instance by invoking the default private constructor.<\/p>\n<p>The singleton implementation validity is checked like indicated above.<\/p>\n<p>Here are serialize and deserialize functions:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public void Serialize(this object obj, string filename)\r\n{\r\n  if ( !obj.GetType().IsSerializable )\r\n    throw new IOException(SystemManager.Language.Get(\"ObjectIsNotSerializable\",\r\n                          obj.GetType().Name));\r\n  using ( FileStream f = new FileStream(filename,\r\n                                        FileMode.Create, \r\n                                        FileAccess.Write, \r\n                                        FileShare.None) )\r\n    new BinaryFormatter().Serialize(f, obj);\r\n}<\/pre>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public object Deserialize(this string filename)\r\n{\r\n  if ( !File.Exists(filename) )\r\n    throw new IOException(SystemManager.Language.Get(\"FileNotFound\",\r\n                          filename));\r\n  using ( FileStream f = new FileStream(filename,\r\n                                        FileMode.Open, \r\n                                        FileAccess.Read, \r\n                                        FileShare.None) )\r\n    return new BinaryFormatter().Deserialize(f);\r\n}<\/pre>\n<h3>Coding the singleton<\/h3>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">namespace Ordisoftware.Core.ObjectModel\r\n{\r\n  [Serializable]\r\n  abstract public class Singleton &lt; T &gt; where T : Singleton\r\n  {\r\n    static private readonly object locker = new object();\r\n\r\n    static protected void DoError(string s)\r\n    {\r\n      throw new SingletonException(SystemManager.Language.Get(s), typeof(T));\r\n    }\r\n\r\n    static public string Filename\r\n    {\r\n      get { return _Filename; }\r\n      set\r\n      {\r\n        if ( _Filename == value ) return;\r\n        lock ( locker )\r\n        {\r\n          if ( FileTool.Exists(_Filename) ) FileTool.Move(_Filename, value);\r\n          _Filename = value;\r\n        }\r\n      }\r\n    }\r\n    static private volatile string _Filename;\r\n\r\n    static public void Save()\r\n    {\r\n      lock ( locker )\r\n        if ( !( _Filename.IsNullOrEmpty() &amp;&amp; Instance.IsNull() ) )\r\n        {\r\n          FolderTool.Check(_Filename);\r\n          Instance.Serialize(_Filename);\r\n        }\r\n    }\r\n\r\n    ~Singleton()\r\n    {\r\n      try { Save(); }\r\n      catch (Exception e) { ShowError(e.Message); }\r\n    }\r\n\r\n    static public T Instance\r\n    {\r\n      get\r\n      {\r\n        lock ( locker )\r\n        {\r\n          if ( _Instance == null )\r\n            if ( FileTool.Exists(_Filename) ) \r\n              _Instance = (T)_Filename.Deserialize();\r\n            else _Instance = CreateInstance();\r\n          return _Instance;\r\n        }\r\n      }\r\n    }\r\n    static private volatile T _Instance;\r\n\r\n    static public T GetInstance()\r\n    {\r\n        return Instance;\r\n    }\r\n\r\n    static public T GetPersistentInstance(string filename)\r\n    {\r\n      Filename = filename;\r\n      return Instance;\r\n    }\r\n\r\n    static public T GetPersistentInstance()\r\n    {\r\n      if ( _Instance != null ) return _Instance;\r\n      Type type = typeof(T);\r\n      string s = type.Namespace + '.' + type.Name.Replace('`', '_');\r\n      foreach ( Type t in type.GetGenericArguments() ) s += \" \" + t.FullName;\r\n      s = SystemManager.FolderSystem + s + SystemManager.ExtObjectFile;\r\n      return GetPersistentInstance(s);\r\n    }\r\n\r\n    static private T CreateInstance()\r\n    {\r\n      return (T)CheckImplementation().Invoke(null);\r\n    }\r\n\r\n    static internal ConstructorInfo CheckImplementation()\r\n    {\r\n      Type type = typeof(T);\r\n      if ( !type.IsSealed ) DoError(\"SingletonMustBeSealed\");\r\n      var bf1 = BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public;\r\n      var bf2 = BindingFlags.Instance | BindingFlags.Public;\r\n      var bf3 = BindingFlags.Instance | BindingFlags.NonPublic;\r\n      if ( type.GetMembers(bf1).Length != 0 ) \r\n        DoError(\"SingletonNoStaticMembers\");\r\n      if ( type.GetConstructors(bf2).Length != 0 ) \r\n        DoError(\"SingletonNoPublicConstructors\");\r\n      ConstructorInfo[] list = type.GetConstructors(bf3);\r\n      if ( ( list.Length != 1 ) || ( list[0].GetParameters().Length != 0 )\r\n        || ( !list[0].IsPrivate ) )\r\n        DoError(\"SingletonOnlyOnePrivateConstructor\");\r\n      return l[0];\r\n    }\r\n  }\r\n}<\/pre>\n<h3>Startup checking<\/h3>\n<pre class=\"lang:c# decode:true prettyprint lang-cs crayon-selected\">namespace Ordisoftware.Core\r\n{\r\n  static public class SystemManager\r\n  {\r\n    static public void Initialize()\r\n    {\r\n      Type type = Type.GetType(\"Ordisoftware.Core.ObjectModel.Singleton`1\");\r\n      if ( type != null )\r\n      {\r\n        MethodInfo method;\r\n        string name = \"CheckImplementation\";\r\n        var bf = BindingFlags.InvokeMethod | BindingFlags.FlattenHierarchy\r\n               | BindingFlags.Static | BindingFlags.NonPublic;\r\n        var list = ObjectUtility.GetClasses(\r\n          t =&gt; ( t.BaseType.Name == type.Name )\r\n            &amp;&amp; ( t.BaseType.Namespace == type.Namespace ));\r\n        foreach ( var t in list )\r\n          try\r\n          {\r\n            if ( !t.ContainsGenericParameters ) method = t.GetMethod(name, bf);\r\n            else\r\n            {\r\n              Type[] p = t.GetGenericArguments();\r\n              for ( int i = 0; i &lt; p.Length; i++ ) p[i] = typeof(object);\r\n              method = t.MakeGenericType(p).GetMethod(name, bf);\r\n            }\r\n            method.Invoke(null, new object[0]);\r\n          }\r\n          catch ( Exception e ) { ShowException(e); }\r\n      }\r\n    }\r\n  }\r\n}<\/pre>\n<p>Here is the GetClasses function:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static public TypeList GetClasses(Func select)\r\n{\r\n  return GetList(t =&gt; t.IsClass, select);\r\n}<\/pre>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static private TypeList GetList(Func check, Func select)\r\n{\r\n  TypeList list = new TypeList();\r\n  Type[] l1 = Assembly.GetExecutingAssembly().GetTypes();\r\n  if ( select == null ) list.AddRange(l1);\r\n  else\r\n    foreach ( Type t in l1 )\r\n      if ( check(t) &amp;&amp; select(t) ) list.Add(t);\r\n  Module[] l2 = Assembly.GetEntryAssembly().GetLoadedModules();\r\n  if ( select == null ) list.AddRange(l1);\r\n  else\r\n    foreach ( Module m in l2 )\r\n      foreach ( Type t in m.Assembly.GetTypes() )\r\n        if ( check(t) &amp;&amp; select(t) ) list.Add(t);\r\n  list.Sort((v1, v2) =&gt; v1.FullName.CompareTo(v2.FullName));\r\n  return list;\r\n}<\/pre>\n<h3>Example of usage<\/h3>\n<p align=\"justify\">Each execution adds 10 to the value displayed by this program:<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">[Serializable]\r\npublic class MySingleton : Singleton &lt; MySingleton &gt;\r\n{\r\n  public int Value { get; set; }\r\n  private MySingleton() { }\r\n}<\/pre>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">static class Program\r\n{\r\n  [STAThread]\r\n  static void Main(string[] args)\r\n  {\r\n    SystemManager.Initialize();\r\n    try\r\n    {\r\n      var v = MySingleton.GetPersistentInstance();\r\n      v.Value += 10;\r\n      Console.WriteLine(\"MySingleton.Value = \" + MySingleton.Instance.Value);\r\n    }\r\n    catch ( Exception e ) { Debugger.ManageException(null, e); }\r\n    finally { SystemManager.Finalize(); }\r\n  }\r\n}<\/pre>\n<h3>The missing \"singleton\" language keyword<\/h3>\n<p>The best way to implement a singleton in C# is to create a static class, but this may cause a problem with serialization and with when the object is initialized, whether one considers laziness.<\/p>\n<p>The ideal thing would be to have a language keyword like singleton: an artifact having no static members and only one constructor with no parameter and no access modifier. It can be inherited only if marked as abstract. It may be used like a static class but will act like an instancied class. It may be serializable and disposable: the first usage deserializes the object if a stream is associated or creates a new single instance, disposing serializes the singleton or does nothing if no stream is associated, changing the stream moves the instance from the old to the new place, and setting a stream on a singleton already instancied causes a usage exception if the new stream localizes an item that exists.<\/p>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">[Serializable]\r\n[SingletonPersistence(false)]  \/\/ don't use a default system stream\r\npublic singleton MySingleton\r\n{\r\n  public int Value {get; set; }\r\n  MySingleton()\r\n  {\r\n    \/\/ Code executed on first access\r\n  }\r\n}<\/pre>\n<pre class=\"lang:c# decode:true prettyprint lang-cs\">var stream1 = new SingletonFileStream(\"c:mysingleton.bin\");\r\nvar stream2 = new SingletonSystemStream();\r\nMySingleton.SetStream(stream1);\r\nMySingleton.Value += 10;\r\nMySingleton.SetStream(stream2);\r\nMySingleton.Value += 10;\r\nMySingleton.SaveState();<\/pre>\n<h3>Recommended articles<\/h3>\n<p style=\"padding-left: 30px; margin-bottom: 0px;\"><a href=\"http:\/\/www.yoda.arachsys.com\/csharp\/singleton.html\" target=\"_blank\">Implementing the Singleton Pattern in C#<\/a><\/p>\n<p style=\"padding-left: 30px; margin-bottom: 0px;\"><a href=\"http:\/\/www.codeproject.com\/KB\/cs\/FunWithSingletonsCS.aspx\" target=\"_blank\">Fun with Singletons in C# 2.0<\/a><\/p>\n<p style=\"padding-left: 30px; margin-bottom: 0px;\"><a href=\"http:\/\/www.codeproject.com\/KB\/architecture\/GenericSingletonPattern.aspx\" target=\"_blank\">Generic Singleton Pattern using Reflection in C#<\/a><\/p>\n<p style=\"padding-left: 30px; margin-bottom: 0px;\"><a href=\"http:\/\/geekswithblogs.net\/akraus1\/articles\/90803.aspx\" target=\"_blank\">Lazy Vs Eager Init Singletons \/ Double-Check Lock Pattern<\/a><\/p>\n<p style=\"padding-left: 30px; margin-bottom: 0px;\"><a href=\"http:\/\/www.c-sharpcorner.com\/UploadFile\/snorrebaard\/GenericSingleton11172008110419AM\/GenericSingleton.aspx\" target=\"_blank\">The quest for the Generic singleton in C#<\/a><\/p>\n<p><\/p>\n<\/p>","protected":false},"excerpt":{"rendered":"<p style=\"margin-bottom:25px;\">\n<p> The paradigm <\/p>\n<p>Consider this common singleton pattern implementation:<\/p>\n<p> public class Singleton { static private readonly object locker = new object(); static public Singleton Instance { get { lock ( locker ) { if ( _Instance == null ) _Instance = new Singleton(); return _Instance; } } } static private volatile Singleton _Instance; private Singleton() { } } <\/p>\n<p>The problem is that you can inherit this class and create a public constructor if there is no private constructor. Furthermore, static members are allowed. This is no longer a singleton at all. Setting the class as sealed can be an <\/p>\n<p><span style=\"color:#333\"> &rarr; <a href=\"https:\/\/www.ordisoftware.com\/blog\/2009\/07\/design-flaws-of-the-singleton-pattern-in-csharp\/\">Lire la suite<\/a><\/span><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[54],"tags":[53,28,46,55,56,34,57,31,58,37,59,60,47,51,61,50,62,39,33,63,40],"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts\/622"}],"collection":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/comments?post=622"}],"version-history":[{"count":0,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/posts\/622\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/media?parent=622"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/categories?post=622"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/wp-json\/wp\/v2\/tags?post=622"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}