{"id":7930,"date":"2021-09-04T14:37:53","date_gmt":"2021-09-04T12:37:53","guid":{"rendered":"https:\/\/www.ordisoftware.com\/?p=7930"},"modified":"2021-09-04T21:10:15","modified_gmt":"2021-09-04T19:10:15","slug":"is-everything-an-object-in-dotnet-and-csharp","status":"publish","type":"post","link":"https:\/\/www.ordisoftware.com\/en\/blog\/2021\/09\/is-everything-an-object-in-dotnet-and-csharp\/","title":{"rendered":"Is everything an object in .NET and C#?"},"content":{"rendered":"<p style=\"margin-bottom:25px;\"><p>In .NET and C# all is <a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.object\" rel=\"nofollow noreferrer\">object<\/a>.<\/p>\n<p>Simply said.<\/p>\n<p>Even a <a href=\"https:\/\/referencesource.microsoft.com\/#mscorlib\/system\/valuetype.cs,915ba3e46633f948\" rel=\"nofollow noreferrer\">value type<\/a>, a <a href=\"https:\/\/digitteck.com\/dotnet\/csharp-class-vs-struct\/\" rel=\"nofollow noreferrer\">struct<\/a>, an interface and an enum.<\/p>\n<p>One can not approve, but the point is that everything is object, except pointers\/references, and literals from binary files, even CPU optimized primitive types, since it is the OOP Theory as well as the. NET specifications and therefore the facts.<\/p>\n<p><!--more--><\/p>\n<h3>About classes and types<\/h3>\n<p>From the <a href=\"https:\/\/github.com\/dotnet\/csharplang\/blob\/main\/spec\/types.md\" rel=\"nofollow noreferrer\">dotnet\/csharplang\/Type<\/a>:<\/p>\n<blockquote><p>Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.<\/p><\/blockquote>\n<blockquote><p>C#'s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the object class type, and object is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type object. Values of value types are treated as objects by performing boxing and unboxing operations (Boxing and unboxing).<\/p><\/blockquote>\n<p>That said in fact that value types are object themselves, even if in IL they are manipulated by references, that is called an \"<em>unified type system<\/em>\". That said that <strong>all is object<\/strong>, but some are used <em>via references to values<\/em> and others <em>via values<\/em>. Thus C# is <em>True OOP<\/em> but not <em>Pure<\/em>, mainly for optimizations purpose.<\/p>\n<p>In <a href=\"https:\/\/www.c-sharpcorner.com\/UploadFile\/ajyadav123\/msil-programming-part-2\/\" rel=\"nofollow noreferrer\">IL<\/a> all is a <a href=\"https:\/\/weblogs.asp.net\/kennykerr\/introduction-to-msil-part-3-defining-types\" rel=\"nofollow noreferrer\">class<\/a>. All. Except underlying pointers and thus CPU registers, and literals before associated to an object.<\/p>\n<p><a href=\"https:\/\/dotnetfiddle.net\/U3XiD3\" rel=\"nofollow noreferrer\">We can check if any variable is type of object and all is always true (Fiddle)<\/a><\/p>\n<p>All strings, numbers, enums, structs, classes and interfaces to objects are objects being type of object. It is what is called being a True OOP Language. But C# is not Pure OOP because of primitive value types, numbers and strings optimizations.<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">enum Enumeration { V1, V2 }\r\n\r\nstruct Structure { string person; }\r\n\r\ninterface IClass { }\r\n\r\nclass Class : IClass { }\r\n\r\npublic static void Main()\r\n{\r\n  string myStringInstance = \"test\";\r\n  int myIntegerInstance = 10;\r\n  var myEnumInstance = Enumeration.V1;\r\n  var myListInstance = new List();\r\n  var myStructInstance = new Structure();\r\n  var myClassInstance = new Class();\r\n  var myInterface = (IClass)myClassInstance;\r\n\r\n  Console.WriteLine(myStringInstance is object);\r\n  Console.WriteLine(myIntegerInstance is object);\r\n  Console.WriteLine(myEnumInstance is object);\r\n  Console.WriteLine(myListInstance is object);\r\n  Console.WriteLine(myStructInstance is object);\r\n  Console.WriteLine(myClassInstance is object);\r\n  Console.WriteLine(myInterface is object);\r\n  Console.ReadKey();\r\n}\r\n<\/code><\/pre>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">True\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\nTrue\r\n<\/code><\/pre>\n<p>Now let's see the differences between a class and a struct at the IL low-level generated code, before converted to the target machine code:<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">struct Struct { public int Value; }\r\n\r\nclass Class { public int Value; }\r\n\r\npublic static void Main()\r\n{\r\n  var myClass = new Class();\r\n  myClass.Value = 10;\r\n  Console.WriteLine(myClass.Value);\r\n\r\n  var myStruct = new Struct();\r\n  myStruct.Value = 20;\r\n  Console.WriteLine(myStruct.Value);\r\n}\r\n<\/code><\/pre>\n<p>This is what it looks like:<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">.maxstack 2\r\n.entrypoint\r\n.locals init (\r\n  [0] class Program\/Class myClass,\r\n  [1] valuetype Program\/Struct myStruct\r\n)\r\n\r\n\/\/ Class @class = new Class();\r\nIL_0001: newobj instance void Program\/Class::.ctor()\r\nIL_0006: stloc.0\r\n\r\n\/\/ @class.Value = 10;\r\nIL_0007: ldloc.0\r\nIL_0008: ldc.i4.s 10\r\nIL_000a: stfld int32 Program\/Class::Value\r\n\r\n\/\/ Console.WriteLine(@class.Value);\r\nIL_000f: ldloc.0\r\nIL_0010: ldfld int32 Program\/Class::Value\r\nIL_0015: call void [mscorlib]System.Console::WriteLine(int32)\r\n\r\nIL_001b: ldloca.s 1\r\n\r\n\/\/ Struct @struct = default(Struct);\r\nIL_001d: initobj Program\/Struct\r\n\r\n\/\/ @struct.Value = 20;\r\nIL_0023: ldloca.s 1\r\nIL_0025: ldc.i4.s 20\r\nIL_0027: stfld int32 Program\/Struct::Value\r\n\r\n\/\/ Console.WriteLine(@struct.Value);\r\nIL_002c: ldloc.1\r\nIL_002d: ldfld int32 Program\/Struct::Value\r\nIL_0032: call void [mscorlib]System.Console::WriteLine(int32)\r\n<\/code><\/pre>\n<p>So let's say that here, at this level, there is no real difference between an object instance of a class and an object instance of a structure because the compiler does the job of treating them according to their gender. And so that they have the behavior of reference type or value type. Otherwise there, in assembly, there is not really any difference any more except when it is necessary but all is pointers. Almost everything, way of speaking, towards memory cases essentially via CPU registers.<\/p>\n<p><a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.newobj\" rel=\"nofollow noreferrer\">newobj<\/a><\/p>\n<p><a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.initobj\" rel=\"nofollow noreferrer\">initobj<\/a><\/p>\n<p>As we can see, class or struct, it is an <code>object<\/code>, handled in two ways, but in the same way, as in a two-lane road.<\/p>\n<h3>About objects and instances<\/h3>\n<p>Terms <em>object<\/em> and <em>instance<\/em> can be considered synonyms, but they are not really synonymous from the point of view of scrupulous terminology. The <em>object<\/em> is the concrete materialization of the <em>type<\/em> (concept or idea) in the real world (the virtual compouter world, thus the physical memory). The <em>instance<\/em> is rather the mental existence of this <em>object<\/em>, in the human mind, therefore in the software code. So these words are \"synonyms\", but:<\/p>\n<p>An <em>object<\/em> (existence) is an <em>instance<\/em> (presence) of a <em>type<\/em> (thought).<\/p>\n<p>In C# .NET managed code, there is no pointer. Pointers are not objects. Pointers are the address of objects stored in memory. In C# we use references that are hiddens pointers to forget to manage them. A pointer is just a memory cell address like in a town. We could say that they are objects, but not in the sense of objects in OOP: these pointers, via the references, allow us to create, manipulate and destroy the objects that we use to build applications that runs on a machine to take data, process data and output data and\/or control another device.<\/p>\n<p>In OOP, all is object: <a href=\"https:\/\/en.wikipedia.org\/wiki\/Object_(computer_science)\" rel=\"nofollow noreferrer\">en.wikipedia.org\/wiki\/Object_(computer_science)<\/a>.<\/p>\n<p>An <a href=\"https:\/\/en.wikipedia.org\/wiki\/Object-oriented_programming\" rel=\"nofollow noreferrer\">object<\/a> is an <a href=\"https:\/\/en.wikipedia.org\/wiki\/Instance_(computer_science)#Object_oriented_programming\" rel=\"nofollow noreferrer\">instance<\/a> of a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Object_type_(object-oriented_programming)\" rel=\"nofollow noreferrer\">type<\/a>.<\/p>\n<p>The words <em>object<\/em> and <em>instance<\/em> can be considered synonyms, but they are not really synonymous from the point of view of scrupulous terminology. The object is the concrete materialization of the type or concept or idea in the real world, in the physical memory. The instance is the mental existence of this object, in the human mind, in the software code. So these words are \"synonyms\", but <em>an <a href=\"https:\/\/en.wiktionary.org\/wiki\/object\" rel=\"nofollow noreferrer\">object<\/a> (existence) is an <a href=\"https:\/\/en.wiktionary.org\/wiki\/instance\" rel=\"nofollow noreferrer\">instance<\/a> (presence) of a <a href=\"https:\/\/en.wiktionary.org\/wiki\/type\" rel=\"nofollow noreferrer\">type<\/a> (thought)<\/em>.<\/p>\n<p>Words <em>type and class or struct<\/em> are not synonyms. One can consider object and instance synonyms, but not these words: class, struct, enum or interface are types. For example, a chair and a table are furniture, but chair and furniture are not synonyms. One can imagine that the word <a href=\"https:\/\/en.wikipedia.org\/wiki\/Type_theory\" rel=\"nofollow noreferrer\"><em>type<\/em><\/a> is the \"root class\" (parent concept) and words <em>class<\/em> or <em>struct<\/em>... are \"child classes\" (child concepts), in terms of linguistic. So they are not synonyms: there is a level of abstraction that make the difference, like in a tree of terminology.<\/p>\n<p><em>An instance (the data in the mind to be manipulated by the code) of a struct type (the static definition)<\/em> <strong>is<\/strong> <em>an object (in the computer memory).<\/em><\/p>\n<p>One can find answers to fundamental questions by studying the basics up to Intel. To understand the motor of the car we need to open the hood, not to dissect the steering wheel or the tires nor the armchairs. To understand the underlying of virtual .NET we need to study the CPU itself, and that, is fascinating, else we can easily lost time and misunderstood things with confusion and non-sense - same for C# based on OOP Theory.<\/p>\n<p>Sometimes source of knowledge the web as well as in books may be partial or misleading due to errors, oversight, misunderstanding, confusion, or ignorance. Hence the importance of starting with few sources of few experts, like one or two reliable and reputable origin, from the basics, and books or professional courses are the best, rather than scattering. Once mastered, we can open the field and domains with more and don't be scared about discrepancies or contradictions.<\/p>\n<h3>About boxing and unboxing<\/h3>\n<p>A variable, an object in OOP, that is an instance of a struct or a class, can be boxed to <code>object<\/code> and unboxed from <code>object<\/code> : <a href=\"https:\/\/docs.microsoft.com\/dotnet\/csharp\/programming-guide\/types\/boxing-and-unboxing\" rel=\"nofollow noreferrer\">C# Guide<\/a>. Essentially, unboxed, a value type is an <code>object<\/code> that doesn't look like an <code>object<\/code> (it is \"shrunken\") in order to be optimized for processing by our silicon microprocessors, so there are a lot of speed and memory improvements in the IL code and therefore in the targeted machine code. Boxed, this value type is a full object as such, put in an entire box, and being no longer cheap. A boxed value type is used as the full object without optimizations and sepcial behaviors: it is now a reference we manipulate to access the embedded value in the \"original\" class.<\/p>\n<p>An unboxed value is the value itself ie the memory cell itself if an integer, in the RAM memory and\/or CPU register being x32 or nowadays x64 (one cell here). A boxed value is a reference to a <a href=\"https:\/\/referencesource.microsoft.com\/#mscorlib\/system\/int64.cs,e566178cce890c36,references\" rel=\"nofollow noreferrer\">full object instance<\/a> embedding this <a href=\"https:\/\/referencesource.microsoft.com\/#mscorlib\/system\/int64.cs,514dc1adf652dad1,references\" rel=\"nofollow noreferrer\">value<\/a> (many cells). The unboxed is manipulated without using \"all the full\" but the boxed use that. Thus this last is slower and bigger. But an apple remains an apple. For example, if a method requires an object instance being of type <code>Object<\/code>, we must box an integer, because it only accepts the root type of all.<\/p>\n<p>That means that boxing take an <em>optimized ie a not-pure object<\/em> like an integer value (a one memory cell) to create a <em>full object<\/em> <code>Int32<\/code>. Thus this one-cell memory in the stack in assigned to the <code>int<\/code> <a href=\"https:\/\/referencesource.microsoft.com\/#mscorlib\/system\/int32.cs,e684b180141a1959,references\" rel=\"nofollow noreferrer\">property<\/a> of the new <code>Int32<\/code> object in the heap.<\/p>\n<p>Isn't boxing &amp; unboxing a special case of direct casting?<\/p>\n<p>We call that boxing and unboxing because once boxed to <code>object<\/code> type, we can unbox without having a compiler type conversion error as any type mismatch will be raised at runtime.<\/p>\n<p>From <a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.box\" rel=\"nofollow noreferrer\">OpCodes.Box Field<\/a>:<\/p>\n<blockquote><p>Converts a value type to an object reference (type O).<\/p>\n<p>The stack transitional behavior, in sequential order, is:<\/p>\n<ol>\n<li>A value type is pushed onto the stack.<\/li>\n<li>The value type is popped from the stack; the box operation is performed.<\/li>\n<li>An object reference to the resulting \"boxed\" value type is pushed onto the stack.<\/li>\n<\/ol>\n<p>A value type has two separate representations within the Common Language Infrastructure (CLI):<\/p>\n<ul>\n<li>A 'raw' form used when a value type is embedded within another object or on the stack.<\/li>\n<li>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.<\/li>\n<\/ul>\n<p>The box instruction converts the 'raw' (unboxed) value type into an object reference (type O). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. valTypeToken is a metadata token indicating the type of the value type on the stack.<\/p><\/blockquote>\n<p>In terms of machine code material architecture dependant as with an Intel-type microprocessor, it is nothing more than using a memory pointer after performing all the specified processings.<\/p>\n<p>Here is another sample:<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">int valueInt = 10;\r\ndouble valueDouble = (double)valueInt;\r\nobject instance = (object)valueInt;\r\nint value = (int)instance;\r\n<\/code><\/pre>\n<p>IL generated code is:<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">.method private hidebysig static \r\n    void Test () cil managed \r\n{\r\n    .maxstack 1\r\n    .locals init (\r\n        [0] int32 valueInt,\r\n        [1] float64 valueDouble,\r\n        [2] object 'instance',\r\n        [3] int32 'value'\r\n    )\r\n\r\n    \/\/ int num = 10;\r\n    IL_0001: ldc.i4.s 10\r\n    IL_0003: stloc.0\r\n\r\n    \/\/ double num2 = num;\r\n    IL_0004: ldloc.0\r\n    IL_0005: conv.r8\r\n    IL_0006: stloc.1\r\n\r\n    \/\/ object obj = num;\r\n    IL_0007: ldloc.0\r\n    IL_0008: box [mscorlib]System.Int32\r\n    IL_000d: stloc.2\r\n\r\n    \/\/ int num3 = (int)obj;\r\n    IL_000e: ldloc.2\r\n    IL_000f: unbox.any [mscorlib]System.Int32\r\n    IL_0014: stloc.3\r\n\r\n    IL_0010: ret\r\n}\r\n<\/code><\/pre>\n<p>From <a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.unbox\" rel=\"nofollow noreferrer\">OpCodes.Unbox Field<\/a>:<\/p>\n<blockquote><p>Converts the boxed representation of a value type to its unboxed form.<\/p>\n<p>The stack transitional behavior, in sequential order, is:<\/p>\n<ol>\n<li>An object reference is pushed onto the stack.<\/li>\n<li>The object reference is popped from the stack and unboxed to a value type pointer.<\/li>\n<li>The value type pointer is pushed onto the stack.<\/li>\n<\/ol>\n<p>A value type has two separate representations within the Common Language Infrastructure (CLI):<\/p>\n<ul>\n<li>A 'raw' form used when a value type is embedded within another object.<\/li>\n<li>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.<\/li>\n<\/ul>\n<p>The unbox instruction converts the object reference (type O), the boxed representation of a value type, to a value type pointer (a managed pointer, type &amp;), its unboxed form. The supplied value type (valType) is a metadata token indicating the type of value type contained within the boxed object.<\/p>\n<p>Unlike Box, which is required to make a copy of a value type for use in the object, unbox is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.<\/p><\/blockquote>\n<p>Since classes and structures are in fact the same thing, of course managed differently, but being only references and \"hidden-references\" (hidden and \"hidden-hidden\" memory pointers to forget to manage them as well as accessing and using, and to delegate this to the CLR), boxing and unbowing of value-types and non-value-types is essentially the same at this low level of operation, so the IL code does not differentiate between the two.<\/p>\n<h3>About literals and binary file<\/h3>\n<p>Concerning literals, they can't be considered as objects because they are hard-coded in the EXE binary. The running machine code loads a literal value (or its address to be associated to the new created object) from the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Data_segment\" rel=\"nofollow noreferrer\">data-segment<\/a> in a register and\/or in a variable reserved cell address when we write <code>int a = 10;<\/code> : the 10 is in the EXE data segment loaded at startup in memory. That, is not an object in term of OOP: it just some raw contiguous bytes (integer, string, arrays of integral types): literals are not variables and nothing about variables applies to literals which are <a href=\"https:\/\/en.wikipedia.org\/wiki\/Binary_file\" rel=\"nofollow noreferrer\">pure raw data<\/a> without any abstraction or encapsulation.<\/p>\n<pre class=\"lang-cs s-code-block\"><code class=\"hljs language-csharp\">.maxstack 1\r\n.locals init ( [0] string str )\r\n\r\n\/\/ string str = \"This a literal test string for Stack Overflow!\";\r\nIL_0001: ldstr \"Test\"\r\nIL_0006: stloc.0\r\n\r\n\/\/ Console.WriteLine(str);\r\nIL_0007: ldloc.0\r\nIL_0008: call void [mscorlib]System.Console::WriteLine(string)\r\n<\/code><\/pre>\n<p>This IL instruction in the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Code_segment\" rel=\"nofollow noreferrer\">code-segment<\/a> loads the \"This is a literal test...\" raw bytes stored in the binary EXE file in <a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.ldstr\" rel=\"nofollow noreferrer\">a <code>str<\/code> object instance<\/a> created and being of type string and referenced by the memory address pointer in the stack at position \"0\", and then this local reference is <a href=\"https:\/\/docs.microsoft.com\/dotnet\/api\/system.reflection.emit.opcodes.ldloc_0\" rel=\"nofollow noreferrer\">passed<\/a> to the Console method.<\/p>\n<p>Here is a compiler generated EXE dump, wagons of raw bytes stored in the data segment loaded when the process started and used to create the new string instance like using a scanner to create an image file:<\/p>\n<p><a href=\"https:\/\/i.stack.imgur.com\/TJDUt.png\" rel=\"nofollow noreferrer\"><img decoding=\"async\" src=\"https:\/\/i.stack.imgur.com\/TJDUt.png\" alt=\"enter image description here\" \/><\/a><\/p>\n<p>The raw bytes of a file are not objects as such as considered in OOP: they become objects when instances are created once the application is started, to load pre-defined data or to handle files. They are just raw bytes before the program is running, not objects, not yet.<\/p>\n<h3>About OOP and machine code<\/h3>\n<p>All that: .NET, C#, OOP, casting, boxing, unboxing... is just <a href=\"https:\/\/en.wikipedia.org\/wiki\/High-level_programming_language\" rel=\"nofollow noreferrer\">high-level language<\/a> sugar over <a href=\"https:\/\/en.wikipedia.org\/wiki\/Machine_code\" rel=\"nofollow noreferrer\">machine code<\/a> to allow humans to be able to do things better and simpler but more complex and more powerful in less time.<\/p>\n<p>We must keep in mind that object (tree) can mean two things : object instance in term of OOP (plant), and C# root for all classes\/structs\/enums <code>object<\/code> (graph). But that's in reality the same thing because all is <code>object<\/code> at the highest level of abstraction. Objects instance of a type being a reference type or a value type, are objects, in the two cases. Its upper typeof is <code>object<\/code> : a struct, a class and a enum is type of <code>object<\/code>. Always. We have checked that by code and see what is the truth.<\/p>\n<p>In C# .NET OOP, all objects are type of <code>Object<\/code> class, and any struct is in fact a class, a special class: for IL it is a sub-class of Object. Also any interface is a class, a special class: for IL it is a sub-class of Object. This said in a simplified way.<\/p>\n<p>By writting <code>Object<\/code> we ensure that we talk about the root class type that is the ancestor of all .NET types (classes, structs, enums, numbers). When we talk about objects we refer to instance of type being of this System.Object root class. Also objects types can be references or value type: that is how the compiler manage special cases and behaviors and optimizations... Thus this comment is misleading. Forget it.<\/p>\n<p>In OOP, everything is an object. This is the theory. Even value types are objects, specials compared to other classes. Everything is explained in duplicates. It is impossible to understand in such fundamental low-level objects nature, memory as well as coding, without learning this theory and how the motherboard works. Impossible without confusion and asking the same questions eternally, in my opinion. It is like trying to understand what are stars without studying atoms.<\/p>\n<p>In OOP, everything is an object. We manipulate objects that have properties or attributes and operations or methods. Even in non-OOP like structured and functionnal. In the end everything is an object whatever its specialized type. The smallest object, the computer atom, is the memory cell and the bit box. Over 0's and 1's of this silicon microprocessor era, the smallest object a computer can store is defined by its register size: 8, 16, 32, 64... bits. This is the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Word_(computer_architecture)\" rel=\"nofollow noreferrer\">basic object<\/a>: byte word dword qword... All is matter.<\/p>\n<p>An object (an object is an instance of a class) of type <a href=\"https:\/\/referencesource.microsoft.com\/#mscorlib\/system\/valuetype.cs,915ba3e46633f948\" rel=\"nofollow noreferrer\">ValueType<\/a> is of type a class that inherits from <code>object<\/code> C# class. Thus all is class is C#, even interfaces (in IL).<\/p>\n<p>What is it if not an object? In life and in the universe, everything is object, movement, construction, interaction, evolution, destruction... Any event relating to a phenomenon requires a physical support, and this support is called object, intsance of the phenomenon (concepts and laws). Nothing exists without matter. Those who say otherwise are just liars. So if a value-type, integral\/struct\/str, that is at the top level a class aka an object, <em>otherwise what is it<\/em>? <em>A spirit<\/em> ? But spirit is matter: the object, alive (made and moving) as well as dead (des not move and is garbadged)<\/p>\n<p>It is the OOP Theory that does that. It is <a href=\"https:\/\/en.wikipedia.org\/wiki\/Object-oriented_programming#History\" rel=\"nofollow noreferrer\">those who developed<\/a> this theory who stated that. I just agree. It's the same with the <em>Cell Theory<\/em> which states that all life comes from the cell (DNA\/RNA\/Organites) and nothing else than the laws like gravity.<\/p>\n<p>In OOP everything is <code>object<\/code> = <code>Object<\/code> even in C# where all is an object of type a class even integral types, structs, numbers and enums as well as strings. Nothing else. It does not matter at this level of abstraction what nuances we bring to the types of objects.<\/p>\n<p>In contrast to that, at low-level, in virtual IL assembly and in CPU-ASM machine code, numbers are simple bytes values in the CPU internal registers, thus they are not OOP objects... But such consideration without knowing what about we call is confusing because C# manipulates objects, all is object, even once compiler optimizations are done unlike in Haskell or Smalltalk, if I remember and don't say an error about these true and pure OOP languages.<\/p>\n<p>DotNet is not pure OOP. For example, when we change the value of an integer, the IL code changes the content of the cell at the address reserved for this value. It uses the same address. It just do what will become a wimple <code>MOV addr, 10<\/code>. It does not create a copy using another cell or object by putting to trash the old cell or object.<\/p>\n<h3>Conclusion<\/h3>\n<p>I encourage anybody to study the foundations of this OOP theory: abstraction, encapsulation, inheritance and polymorphism.<\/p>\n<p>As well as the foundations of computers based on silicium microprocessors on a motherboard having some memory.<\/p>\n<p>But please, don't ask me what is the ancestor of <code>object<\/code>...<\/p>\n<p>The previous and following links are for information and demonstration only. Some are trustworthy, others may contain errors, contradictions or ignorance on the subject, and also opinions, true or false, sometimes difficult to bring into real reality.<\/p>\n<p>Also keep in mind that I could have misconstrued and made inaccuracies or even imperfections, especially since I'm not so good in English, not my mother tongue and I have no oral skills, and my memories in Assembly are old and in old computers before the x64 era, and that I did not too much invested in the IL\/CLR study, but what I explained, basically, it's like that, pretty much.<\/p>\n<h3>Links<\/h3>\n<ul>\n<li><a href=\"https:\/\/www.c-sharpcorner.com\/article\/mutable-and-immutable-class-in-c-sharp\/\" rel=\"nofollow noreferrer\">Mutable And Immutable Class<\/a><\/li>\n<li><a href=\"https:\/\/www.codeproject.com\/Articles\/1043301\/Immutable-objects-in-Csharp\" rel=\"nofollow noreferrer\">Immutable objects<\/a><\/li>\n<li><a href=\"https:\/\/www.pluralsight.com\/guides\/understanding-string-immutability-csharp\" rel=\"nofollow noreferrer\">Understanding String Immutability<\/a><\/li>\n<li><a href=\"https:\/\/www.tutorialsteacher.com\/articles\/boxing-unboxing-in-csharp\" rel=\"nofollow noreferrer\">Boxing and Unboxing in C#<\/a><\/li>\n<li><a href=\"https:\/\/www.geeksforgeeks.org\/c-sharp-boxing-unboxing\/\" rel=\"nofollow noreferrer\">C# Boxing and Unboxing<\/a><\/li>\n<li><a href=\"https:\/\/mattwarren.org\/2017\/08\/02\/A-look-at-the-internals-of-boxing-in-the-CLR\/\" rel=\"nofollow noreferrer\">A look at the internals of 'boxing' in the CLR<\/a><\/li>\n<li><a href=\"https:\/\/www.ordisoftware.com\/en\/blog\/2021\/09\/how-to-improve-your-knowledge-of-csharp\/\">How to improve your knowledge of C#<\/a><\/li>\n<\/ul>\n<p style=\"text-align: right;\"><span style=\"color: #808080;\"><a style=\"color: #808080;\" href=\"https:\/\/stackoverflow.com\/a\/67609162\/12031933\" target=\"_blank\" rel=\"noopener\">CC BY-SA 4.0 Original Post<\/a><\/span><\/p>\n<\/p>","protected":false},"excerpt":{"rendered":"<p style=\"margin-bottom:25px;\">\n<p>In .NET and C# all is object.<\/p>\n<p>Simply said.<\/p>\n<p>Even a value type, a struct, an interface and an enum.<\/p>\n<p>One can not approve, but the point is that everything is object, except pointers\/references, and literals from binary files, even CPU optimized primitive types, since it is the OOP Theory as well as the. NET specifications and therefore the facts.<\/p>\n<p><span style=\"color:#333\"> &rarr; <a href=\"https:\/\/www.ordisoftware.com\/en\/blog\/2021\/09\/is-everything-an-object-in-dotnet-and-csharp\/\">Read next<\/a><\/span><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[54],"tags":[],"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/posts\/7930"}],"collection":[{"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/comments?post=7930"}],"version-history":[{"count":0,"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/posts\/7930\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/media?parent=7930"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/categories?post=7930"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ordisoftware.com\/en\/wp-json\/wp\/v2\/tags?post=7930"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}